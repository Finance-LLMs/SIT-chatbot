import { useState, useEffect, useRef } from 'react';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Mic, StopCircle, Loader, RotateCcw } from "lucide-react";
import { Card } from "@/components/ui/card";
import { useToast } from "@/components/ui/use-toast";
import AnimatedOtter from './AnimatedOtter';
import { fetchVoices, transcribeAudio, getDebateResponse, textToSpeech, Voice } from '@/lib/api';

const debateTopics = [
  { id: 'ai-decisions', value: 'Allowing AI to override human decisions' },
  { id: 'universal-income', value: 'Universal Basic Income is necessary' },
  { id: 'social-media', value: 'Social media does more harm than good' },
  { id: 'remote-work', value: 'Remote work should be the new normal' },
  { id: 'climate-action', value: 'Climate action should take priority over economic growth' },
];

const stanceOptions = [
  { id: 'for', value: 'For the motion' },
  { id: 'against', value: 'Against the motion' },
];

interface Message {
  role: 'user' | 'ai';
  text: string;
  audio?: string;
}

const DebateInterface = () => {
  const [topic, setTopic] = useState<string | undefined>();
  const [stance, setStance] = useState<string | undefined>();
  const [voices, setVoices] = useState<Voice[]>([]);
  const [selectedVoice, setSelectedVoice] = useState<string>('');
  const [isRecording, setIsRecording] = useState(false);
  const [isSpeaking, setIsSpeaking] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);
  const [debateText, setDebateText] = useState<string>('');
  const [chatHistory, setChatHistory] = useState<Message[]>([]);
  const { toast } = useToast();
  
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const audioPlayerRef = useRef<HTMLAudioElement | null>(null);
  
  // Load available voices when component mounts
  useEffect(() => {
    const loadVoices = async () => {
      try {
        const availableVoices = await fetchVoices();
        setVoices(availableVoices);
        
        if (availableVoices.length > 0) {
          setSelectedVoice(availableVoices[0].voice_id);
        }
      } catch (error) {
        console.error('Failed to load voices:', error);
        toast({
          title: "Error loading voices",
          description: "Could not load available voices. Please try again later.",
          variant: "destructive",
        });
      }
    };
    
    loadVoices();
  }, [toast]);
  
  const startRecording = async () => {
    if (!topic || !stance) {
      toast({
        title: "Missing information",
        description: "Please select a topic and your stance before starting the debate.",
        variant: "destructive",
      });
      return;
    }

    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];
      
      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          audioChunksRef.current.push(e.data);
        }
      };
      
      mediaRecorder.onstop = async () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
        await processUserInput(audioBlob);
        
        // Stop all audio tracks to release the microphone
        stream.getTracks().forEach(track => track.stop());
      };
      
      mediaRecorder.start();
      setIsRecording(true);
      toast({
        title: "Recording started",
        description: "Speak your argument and click 'Stop Recording' when finished.",
      });
    } catch (error) {
      console.error('Error accessing microphone:', error);
      toast({
        title: "Microphone access failed",
        description: "Could not access your microphone. Please check your browser permissions.",
        variant: "destructive",
      });
    }
  };
  
  const stopRecording = () => {
    if (mediaRecorderRef.current && isRecording) {
      mediaRecorderRef.current.stop();
      setIsRecording(false);
    }
  };
  
  const processUserInput = async (audioBlob: Blob) => {
    try {
      setIsProcessing(true);
      
      // Step 1: Transcribe audio to text
      const userText = await transcribeAudio(audioBlob);
      if (!userText) {
        throw new Error("Transcription returned empty text");
      }
      
      // Create a URL for the audio blob for playback
      const audioUrl = URL.createObjectURL(audioBlob);
      
      // Add user message to chat history
      const userMessage: Message = {
        role: 'user', 
        text: userText,
        audio: audioUrl
      };
      
      setChatHistory(prev => [...prev, userMessage]);
      setDebateText(userText);
      
      // Step 2: Generate AI debate response
      const debateRound = Math.floor(chatHistory.length / 2) + 1;
      const aiSide = stance === 'for' ? 'against' : 'for';
      
      // Prepare history for the API in the format expected by the backend
      const historyPairs: [string, string][] = [];
      for (let i = 0; i < chatHistory.length; i += 2) {
        if (i + 1 < chatHistory.length) {
          historyPairs.push([
            chatHistory[i].text,
            chatHistory[i + 1].text
          ]);
        }
      }
      
      // Get AI response
      const aiResponse = await getDebateResponse(
        userText,
        historyPairs,
        aiSide,
        debateRound
      );
      
      // Step 3: Convert AI response to speech
      const aiAudioUrl = await textToSpeech(aiResponse, selectedVoice);
      
      // Add AI message to chat history
      const aiMessage: Message = {
        role: 'ai',
        text: aiResponse,
        audio: aiAudioUrl
      };
      
      setChatHistory(prev => [...prev, aiMessage]);
      setDebateText(aiResponse);
      
      // Play the audio response
      if (audioPlayerRef.current) {
        audioPlayerRef.current.src = aiAudioUrl;
        audioPlayerRef.current.onplay = () => setIsSpeaking(true);
        audioPlayerRef.current.onended = () => setIsSpeaking(false);
        audioPlayerRef.current.play();
      }
    } catch (error) {
      console.error('Error processing user input:', error);
      toast({
        title: "Processing error",
        description: "An error occurred while processing your input. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsProcessing(false);
    }
  };
  
  // Reset the debate
  const resetDebate = () => {
    setChatHistory([]);
    setDebateText('');
    
    if (audioPlayerRef.current) {
      audioPlayerRef.current.pause();
    }
    
    toast({
      title: "Debate reset",
      description: "Starting a new debate. Select a topic and stance to begin.",
    });
  };

  return (
    <div className="min-h-screen p-4 md:p-8 flex flex-col md:flex-row items-center justify-center gap-6 md:gap-10">
      {/* Hidden audio player for AI speech */}
      <audio ref={audioPlayerRef} className="hidden" />
      
      <Card className="w-full max-w-md p-6 md:p-8 bg-debator-primary rounded-2xl shadow-lg">
        <div className="flex items-center gap-3 mb-4">
          <div className="bg-debator-button text-white p-2 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
              <path d="M12 14l9-5-9-5-9 5 9 5z"></path>
              <path d="M12 14l6.16-3.422a12.083 12.083 0 01.665 6.479A11.952 11.952 0 0112 20.055a11.952 11.952 0 01-6.824-2.998 12.078 12.078 0 01.665-6.479L12 14z"></path>
              <path d="M12 14l-6.16-3.422a12.083 12.083 0 00-.665 6.479A11.952 11.952 0 0012 20.055a11.952 11.952 0 006.824-2.998 12.078 12.078 0 00-.665-6.479L12 14z"></path>
            </svg>
          </div>
          <div>
            <h2 className="text-2xl font-bold text-white">AI Debator</h2>
            <p className="text-debator-secondary text-sm">Engage in a formal debate with AI</p>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          <div>
            <label htmlFor="topic" className="block text-white text-sm mb-2">Debate Topic</label>
            <Select value={topic} onValueChange={setTopic}>
              <SelectTrigger id="topic" className="border-debator-secondary bg-white">
                <SelectValue placeholder="Select a topic" />
              </SelectTrigger>
              <SelectContent>
                {debateTopics.map((topic) => (
                  <SelectItem key={topic.id} value={topic.id}>{topic.value}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>

          <div>
            <label htmlFor="stance" className="block text-white text-sm mb-2">Your Stance</label>
            <Select value={stance} onValueChange={setStance}>
              <SelectTrigger id="stance" className="border-debator-secondary bg-white">
                <SelectValue placeholder="Select stance" />
              </SelectTrigger>
              <SelectContent>
                {stanceOptions.map((option) => (
                  <SelectItem key={option.id} value={option.id}>{option.value}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        
        {voices.length > 0 && (
          <div className="mb-6">
            <label htmlFor="voice" className="block text-white text-sm mb-2">AI Voice</label>
            <Select value={selectedVoice} onValueChange={setSelectedVoice}>
              <SelectTrigger id="voice" className="border-debator-secondary bg-white">
                <SelectValue placeholder="Select voice" />
              </SelectTrigger>
              <SelectContent>
                {voices.map((voice) => (
                  <SelectItem key={voice.voice_id} value={voice.voice_id}>{voice.name}</SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        )}

        <div className="bg-white rounded-xl p-4 mb-6 min-h-[100px] flex items-center">
          {isProcessing ? (
            <div className="flex items-center justify-center w-full text-gray-400">
              <Loader size={24} className="animate-spin mr-2" />
              <span>Processing your input...</span>
            </div>
          ) : debateText ? (
            <p className="text-debator-text">{debateText}</p>
          ) : (
            <div className="flex items-center justify-center w-full text-gray-400">
              <div className="flex items-center gap-3">
                <div className="bg-gray-100 p-2 rounded-full">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                  </svg>
                </div>
                <span>Click "Start Recording" to begin the debate...</span>
              </div>
            </div>
          )}
        </div>

        <div className="flex gap-3 justify-center">
          {!isRecording ? (
            <Button 
              onClick={startRecording} 
              disabled={isProcessing || isSpeaking}
              className="flex items-center justify-center gap-2 bg-debator-button hover:bg-opacity-90 text-white py-2 px-6 rounded-full transition-all"
            >
              <Mic size={20} />
              Start Recording
            </Button>
          ) : (
            <Button 
              onClick={stopRecording}
              className="flex items-center justify-center gap-2 bg-red-500 hover:bg-red-600 text-white py-2 px-6 rounded-full transition-all"
            >
              <StopCircle size={20} />
              Stop Recording
            </Button>
          )}
          
          <Button 
            onClick={resetDebate}
            variant="outline" 
            className="flex items-center justify-center gap-2 border-debator-secondary text-debator-button py-2 px-6 rounded-full transition-all"
          >
            <RotateCcw size={16} />
            Reset
          </Button>
        </div>
        
        {chatHistory.length > 0 && (
          <div className="mt-6 border-t border-white/20 pt-4">
            <h3 className="text-white font-medium mb-2">Debate History</h3>
            <div className="max-h-[200px] overflow-y-auto">
              {chatHistory.map((msg, i) => (
                <div key={i} className={`mb-3 p-2 rounded-lg ${msg.role === 'user' ? 'bg-white/10' : 'bg-debator-button/20'}`}>
                  <div className="font-medium text-sm text-white/80">
                    {msg.role === 'user' ? '👤 You:' : '🦦 AI:'}
                  </div>
                  <p className="text-sm text-white">{msg.text}</p>
                  {msg.audio && (
                    <audio src={msg.audio} controls className="mt-2 w-full h-8" />
                  )}
                </div>
              ))}
            </div>
          </div>
        )}
      </Card>

      <div className="bg-debator-secondary w-full max-w-[300px] h-[350px] rounded-2xl overflow-hidden shadow-lg">
        <AnimatedOtter speaking={isSpeaking || isRecording} />
      </div>
    </div>
  );
};

export default DebateInterface;
